#include "exploit.h"
#include "main.hpp"
#include <exception>

using namespace std;

namespace offsets {
    namespace player {
        constexpr uintptr_t health = 0x280;
        constexpr uintptr_t max_health = 0x2A0;
        constexpr uintptr_t armor = 0x14B8;
        constexpr uintptr_t god_mode = 0x189;
        constexpr uintptr_t invisible = 0x2C;
        constexpr uintptr_t player_info = 0x10C8;
        constexpr uintptr_t weapon_mgr = 0x10D8;
    }

    namespace vehicle {
        constexpr uintptr_t veh_ptr = 0xD30;
        constexpr uintptr_t handling = 0x938;
        constexpr uintptr_t god_mode = 0x189;
    }

    namespace weapon {
        constexpr uintptr_t recoil = 0x2F4;
        constexpr uintptr_t spread = 0x74;
        constexpr uintptr_t reload_time1 = 0x130;
        constexpr uintptr_t reload_time2 = 0x134;
    }
}

// U¿ycie:
float GetHealth() {
    // ...
    return read_mem<float>(local + offsets::player::health);
}

namespace Vehicle {
    // file-scope cached state (widoczne tylko w tym pliku)
    static bool s_acceleration_active = false;
    static float s_acceleration_original = 0.0f;

    static bool s_brake_active = false;
    static float s_brake_original = 0.0f;

    void VehColor(float R, float G, float B) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;

            DWORD64 veh_base = read_mem<DWORD64>(local + 0xD30);
            if (!veh_base) return;

            DWORD64 veh_model = read_mem<DWORD64>(veh_base + 0x48);
            if (!veh_model) return;

            DWORD64 color_ptr = read_mem<DWORD64>(veh_model + 0x20);
            if (!color_ptr) return;

            // Offsets: RGB
            write_mem<float>(color_ptr + 0xAA, R);  // Red
            write_mem<float>(color_ptr + 0xA9, G);  // Green
            write_mem<float>(color_ptr + 0xA8, B);  // Blue
            });
    }

    void FixEngine(float value) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) { util::Log(util::LogLevel::WARN, "FixEngine: localplayer null"); return; }

            DWORD64 vehiclemanager = read_mem<DWORD64>(local + 0xD30);
            if (!vehiclemanager) { util::Log(util::LogLevel::WARN, "FixEngine: vehiclemanager null"); return; }

            write_mem<float>(vehiclemanager + 0x0280, value);
            write_mem<float>(vehiclemanager + 0x0840, value);
            write_mem<float>(vehiclemanager + 0x0908, value);
            write_mem<float>(vehiclemanager + 0x0844, value);
            write_mem<BYTE>(vehiclemanager + 0x0944, 1);
        });
    }

    void GodModeVehicle(bool enable) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 vehiclemanager = read_mem<DWORD64>(local + 0xD30);
            if (!vehiclemanager) return;
            // Offset 0x189 - vehicle god flag (byte)
            write_mem<BYTE>(vehiclemanager + 0x189, enable ? 1 : 0);
        });
    }

    void VehicleAceleration(bool enable, float value) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 vehiclemanager = read_mem<DWORD64>(local + 0xD30);
            if (!vehiclemanager) return;
            DWORD64 handling = read_mem<DWORD64>(vehiclemanager + 0x938);
            if (!handling) return;

            if (!s_acceleration_active && enable) {
                s_acceleration_original = read_mem<float>(handling + 0x4C);
                s_acceleration_active = true;
            }

            if (enable) {
                write_mem<float>(handling + 0x4C, value);
            } else {
                write_mem<float>(handling + 0x4C, s_acceleration_original);
                s_acceleration_active = false;
            }
        });
    }

    void VehicleBrakeForce(bool enable, float value) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 vehiclemanager = read_mem<DWORD64>(local + 0xD30);
            if (!vehiclemanager) return;
            DWORD64 handling = read_mem<DWORD64>(vehiclemanager + 0x938);
            if (!handling) return;

            if (!s_brake_active && enable) {
                s_brake_original = read_mem<float>(handling + 0x6C);
                s_brake_active = true;
            }

            if (enable) {
                write_mem<float>(handling + 0x6C, value);
            } else {
                write_mem<float>(handling + 0x6C, s_brake_original);
                s_brake_active = false;
            }
        });
    }

    void VehicleGravity(bool enable) {
        SAFE_EXECUTE({
            // NOTE: Original code used 0x189 which collides with vehicle god flag.
            // If true gravity offset is known, replace 0x189 below. Here we keep previous behaviour but log warning.
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 vehiclemanager = read_mem<DWORD64>(local + 0xD30);
            if (!vehiclemanager) return;

            util::Log(util::LogLevel::WARN, "VehicleGravity: using offset 0x189 is suspicious; verify correct offset for gravity.");
            write_mem<float>(vehiclemanager + 0x189, enable ? 60.0f : 9.8f);
        });
    }
}

namespace Weapons {
    static bool s_norecoil_active = false;
    static float s_norecoil_original = 0.0f;

    static bool s_nospread_active = false;
    static float s_nospread_original = 0.0f;

    static bool s_noreload_active = false;
    static float s_noreload_original1 = 0.0f;
    static float s_noreload_original2 = 0.0f;

    void SetAmmoType(float value) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 WeaponMGR = read_mem<DWORD64>(local + 0x10D8);
            if (!WeaponMGR) return;
            write_mem<float>(WeaponMGR + 0x20, value);
        });
    }

    void SetAmmoExplosiveType(float value) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 WeaponMGR = read_mem<DWORD64>(local + 0x10D8);
            if (!WeaponMGR) return;
            write_mem<float>(WeaponMGR + 0x24, value);
        });
    }

    void FillAmmo(float value) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 LocalPL = read_mem<DWORD64>(local + 0x10D8);
            if (!LocalPL) return;

            // TODO: verify correct offset chain for current game version.
            DWORD64 weapon = read_mem<uint32_t>(LocalPL + 0x8);
            if (!weapon) return;
            write_mem<float>(weapon + 0x18, value);
        });
    }

    void NoRecoil(bool enable) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 LocalPL = read_mem<DWORD64>(local + 0x10D8);
            if (!LocalPL) return;
            DWORD64 weaponmanager = read_mem<DWORD64>(LocalPL + 0x20);
            if (!weaponmanager) return;

            if (!s_norecoil_active && enable) {
                s_norecoil_original = read_mem<float>(weaponmanager + 0x2F4); // recoil multiplier
                s_norecoil_active = true;
            }

            if (enable) {
                write_mem<float>(weaponmanager + 0x2F4, 0.0f);
            } else {
                write_mem<float>(weaponmanager + 0x2F4, s_norecoil_original);
                s_norecoil_active = false;
            }
        });
    }

    void NoSpread(bool enable) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 weaponmanager = read_mem<DWORD64>(local + 0x10D8);
            if (!weaponmanager) return;
            weaponmanager = read_mem<DWORD64>(weaponmanager + 0x20);
            if (!weaponmanager) return;

            if (!s_nospread_active && enable) {
                s_nospread_original = read_mem<float>(weaponmanager + 0x74);
                s_nospread_active = true;
            }

            if (enable) {
                write_mem<float>(weaponmanager + 0x74, 0.0f);
            } else {
                write_mem<float>(weaponmanager + 0x74, s_nospread_original);
                s_nospread_active = false;
            }
        });
    }

    void NoReload(bool enable) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            DWORD64 weaponmanager = read_mem<DWORD64>(local + 0x10D8);
            if (!weaponmanager) return;
            weaponmanager = read_mem<DWORD64>(weaponmanager + 0x20);
            if (!weaponmanager) return;

            if (!s_noreload_active && enable) {
                s_noreload_original1 = read_mem<float>(weaponmanager + 0x130);
                s_noreload_original2 = read_mem<float>(weaponmanager + 0x134);
                s_noreload_active = true;
            }

            if (enable) {
                write_mem<float>(weaponmanager + 0x130, 10.0f);
                write_mem<float>(weaponmanager + 0x134, 10.0f);
            } else {
                write_mem<float>(weaponmanager + 0x130, s_noreload_original1);
                write_mem<float>(weaponmanager + 0x134, s_noreload_original2);
                s_noreload_active = false;
            }
        });
    }
}

namespace Player {
    float GetHealth() {
        try {
            uintptr_t local = g_game.localplayer.load();
            if (!local) return 0.0f;
            return read_mem<float>(local + 0x280);
        }
        catch (const std::exception& e) {
            util::Log(util::LogLevel::ERROR, "GetHealth exception: %s", e.what());
            return 0.0f;
        }
    }

    float GetArmor() {
        try {
            uintptr_t local = g_game.localplayer.load();
            if (!local) return 0.0f;
            return read_mem<float>(local + 0x280);
        }
        catch (const std::exception& e) {
            util::Log(util::LogLevel::ERROR, "GetArmor exception: %s", e.what());
            return 0.0f;
        }
    }

    float GetMaxHealth() {
        try {
            uintptr_t local = g_game.localplayer.load();
            if (!local) return 0.0f;
            return read_mem<float>(local + 0x280);
        }
        catch (const std::exception& e) {
            util::Log(util::LogLevel::ERROR, "GetMaxHealth exception: %s", e.what());
            return 0.0f;
        }
    }

    void Godmode(bool enable) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            write_mem<BYTE>(local + 0x189, enable ? 1 : 0);
        });
    }

    void Invisible(bool enable) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            write_mem<BYTE>(local + 0x2C, enable ? 0x1 : 0x37);
        });
    }

    void SetArmor(float armor) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            write_mem<float>(local + 0x14B8, armor);
        });
    }

    void SetHealth(float health) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            write_mem<float>(local + 0x280, health);  // Set current health only
            });
    }

    void SetMaxHealth(float max_health) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            write_mem<float>(local + 0x2A0, max_health);
            });
    }

    void SpeedWalk(bool enable, float speed) {
        SAFE_EXECUTE({
            uintptr_t local = g_game.localplayer.load();
            if (!local) return;
            uintptr_t playerinfo = read_mem<uintptr_t>(local + 0x10C8);
            if (!playerinfo) return;
            write_mem<float>(playerinfo + 0xCF0, enable ? speed : 1.0f);
        });
    }
}